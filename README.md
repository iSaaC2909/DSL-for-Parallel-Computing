# DSL-for-Parallel-Computing

Lexer and Compiler Documentation
================================

Overview
--------
The lexer and compiler are designed to process a simple programming language that supports arithmetic expressions, variable assignments, and basic syntax. The system is divided into several phases:
1. Lexical Analysis: Tokenizes the input source code.
2. Syntax Analysis: Parses the tokens into an Abstract Syntax Tree (AST).
3. Semantic Analysis: Validates the AST for semantic correctness.
4. Intermediate Code Generation: Generates Three-Address Code (TAC) from the AST.
5. Optimization: Optimizes the intermediate code.
6. Code Generation: Generates assembly code from the optimized intermediate code.

Lexer (DFA Class)
-----------------

Purpose
-------
The lexer (implemented in the `DFA` class) is responsible for breaking the input source code into meaningful tokens. It uses a Deterministic Finite Automaton (DFA) to recognize patterns in the input.

Key Features
------------
- Tokenizes identifiers, numbers, strings, operators, and punctuations.
- Handles whitespace and special characters.
- Provides a list of tokens for the parser to process.

Input
-----
- A string representing the source code (e.g., `"x = 10 + 20 * (30 - 5)"`).

Output
------
- A vector of tokens (e.g., `["x", "=", "10", "+", "20", "*", "(", "30", "-", "5", ")"]`).

Example Usage
-------------
```cpp
DFA dfa;
dfa.detect("x = 10 + 20 * (30 - 5)");
vector<string> tokens = dfa.getTokens();


Parser
Purpose
The parser (implemented in the Parser class) constructs an Abstract Syntax Tree (AST) from the tokens generated by the lexer. It uses a recursive descent parsing approach.

Grammar
The parser follows this grammar:

Program       -> Statement*
Statement     -> Assignment | Expression
Assignment    -> Identifier "=" Expression
Expression    -> Term (( "+" | "-" ) Term)*
Term          -> Factor (( "*" | "/" ) Factor)*
Factor        -> Number | Identifier | "(" Expression ")"


Key Features
Parses arithmetic expressions and variable assignments.

Handles operator precedence and associativity.

Generates an AST for semantic analysis and code generation.

Input
A vector of tokens (e.g., ["x", "=", "10", "+", "20", "*", "(", "30", "-", "5", ")"]).

Output
An AST representing the parsed program.

Example Usage

Parser parser(tokens);
auto ast = parser.parseProgram();

Semantic Analyzer
Purpose
The semantic analyzer (implemented in the SemanticAnalyzer class) validates the AST for semantic correctness. It ensures that:

Variables are declared before use.

Operations are performed on compatible types.

Key Features
Uses a symbol table to track variable declarations.

Checks for undeclared variables and type mismatches.

Input
An AST generated by the parser.

Output
Throws an error if semantic rules are violated.

Example Usage

SemanticAnalyzer semanticAnalyzer;
semanticAnalyzer.analyze(ast.get());


Intermediate Code Generator
Purpose
The intermediate code generator (implemented in the IRGenerator class) converts the AST into Three-Address Code (TAC), a low-level representation of the program.

Key Features
Generates TAC instructions for arithmetic operations and assignments.

Uses temporary variables to store intermediate results.

Input
An AST generated by the parser.

Output
A vector of TAC instructions (e.g., ["t0 = 10", "t1 = 20", "t2 = 30 - 5", "t3 = t1 * t2", "t4 = t0 + t3", "x = t4"]).

Example Usage

IRGenerator irGenerator;
irGenerator.generate(ast.get());
irGenerator.print();

Optimizer
Purpose
The optimizer (implemented in the Optimizer class) improves the intermediate code by performing optimizations such as constant folding.

Key Features
Evaluates constant expressions at compile time.

Reduces the number of instructions in the intermediate code.

Input
A vector of TAC instructions.

Output
An optimized vector of TAC instructions.

Example Usage

Optimizer optimizer;
optimizer.optimize(irGenerator.instructions);

Code Generator
Purpose
The code generator (implemented in the CodeGenerator class) translates the optimized intermediate code into assembly code.

Key Features
Generates x86 assembly instructions.

Maps TAC instructions to assembly instructions.

Input
A vector of optimized TAC instructions.

Output
Assembly code (e.g., mov eax, 10, add eax, 20).

CodeGenerator codeGenerator;
codeGenerator.generate(irGenerator.instructions);

Main Workflow
Steps
Lexical Analysis: Tokenize the input.

Syntax Analysis: Parse the tokens into an AST.

Semantic Analysis: Validate the AST.

Intermediate Code Generation: Generate TAC from the AST.

Optimization: Optimize the TAC.

Code Generation: Generate assembly code from the optimized TAC.

Example:

int main() {
    // Input
    string input = "x = 10 + 20 * (30 - 5)";

    // Lexical Analysis
    DFA dfa;
    dfa.detect(input);
    vector<string> tokens = dfa.getTokens();

    // Syntax Analysis
    Parser parser(tokens);
    auto ast = parser.parseProgram();

    // Semantic Analysis
    SemanticAnalyzer semanticAnalyzer;
    semanticAnalyzer.analyze(ast.get());

    // Intermediate Code Generation
    IRGenerator irGenerator;
    irGenerator.generate(ast.get());

    // Optimization
    Optimizer optimizer;
    optimizer.optimize(irGenerator.instructions);

    // Print Intermediate Representation
    cout << "Intermediate Representation (IR):" << endl;
    irGenerator.print();

    // Code Generation
    CodeGenerator codeGenerator;
    cout << "\nGenerated Assembly Code:" << endl;
    codeGenerator.generate(irGenerator.instructions);

    return 0;
}

Example Output
Input

x = 10 + 20 * (30 - 5)

IR:
t0 = 10
t1 = 20
t2 = 30
t3 = 5
t4 = t2 - t3
t5 = t1 * t4
t6 = t0 + t5
x = t6

Generated Assembly Code:

mov eax, 10
mov [t0], eax
mov eax, 20
mov [t1], eax
mov eax, 30
mov [t2], eax
mov eax, 5
mov [t3], eax
mov eax, [t2]
sub eax, [t3]
mov [t4], eax
mov eax, [t1]
imul eax, [t4]
mov [t5], eax
mov eax, [t0]
add eax, [t5]
mov [x], eax
